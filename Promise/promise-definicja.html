<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Untitled Document</title>
     <link href="../../_forma/css/styl.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:100,200,300,400,500,600,700,800,900|Roboto+Mono" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

<style>
.zmienna {
  color: #ffa0a0;
  }
.selektor {
  color: #77e1ff; }
.return{
    color:greenyellow;
}
.watki{
    color:hotpink;
}
.watki,
.return,
.zmienna,
.selektor {
  font-weight: bold;
  }
  #demo{
      background-color: #444;
      color:#eee;
  }

</style>

</head>

<body>
<header>Promise - definicja</header>
<div class="tool">
    Jeżeli teraz taki obiekt Promise zostanie zwrócony przez jakąś funkcję, możemy na takiej funkcji działać tak samo jak powyżej działaliśmy na Promise:<br>
    Jak widzisz już nie musimy wywoływać funkcji z wnętrza asynchronicznych obiektów. W tej chwili nasze funkcje stały się autonomicznymi klockami, które możemy używać jak klasyczne funkcje. Dzięki temu nasz kod staje się o wiele czytelniejszy.
</div>

<div id="demo" style="font-size:1.2rem;text-align:left">
<code>
    <pre>
    function loadContent(url) {
         <span class="return">return</span>  new Promise((<span class="selektor">resolve</span>, <span class = "zmienna">reject</span>) => {
                if(){
                <span class="selektor">resolve</span>( value );
                }else{
                <span class = "zmienna">reject</span>( reason );
                }    
            });
    }
    loadContent(url)
    <span class="watki">.then</span>(result => { /*obietnica spełniona*/ })
    <span class="watki">.catch</span>(err => { /*obietnica odrzucona */})
    </pre>
</code>
</div>
</body>
</html>